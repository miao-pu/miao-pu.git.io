{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"James","text":"lebron james lebron james is my favorite NBA player, today(3.20),his career score rose to second in history.I would like to introduce this great star to you Difficult childhood December 30 1984 Lebron was born in the akron ghetto in ohio,USA.However,his father abandoned him and his mother. He and his mother live in grandma’s rental house.They three depended on each other for survival.Unfortunately his grandma passed away at his 3 years old. Because his mother couldn’t find a stable job,james had moved 12 times since he was 5 James’s basketball enlightment At his 3,his mother give him a basketball as the birthday gift. He loved the baskketball very much.Even when sleeping,he still holding the ball At his 7,james’ exllent atheletic talent caught Coach Walker attention.Walker taught james basketball skills.And the little james always enjoys training .Soon James has surpassed other kids of the same age Young James In four years of high school, he won the state championship three times, and was selected as an American star three times. the AP(associated press ) called him “the son of heaven”. And James was extolled as the first high school student in the US James in NBA In 2003, James was selected by the Cleveland Cavaliers as the champion into NBA Achievements With superb skills and leadership,Jame has won four championships. James Off court very frugal Charitable contribution 2015 project” I Promise”,donated 87 million dollars 2016 donated 41 million 800 thousand dollars to akron and so on Blessing I hope James can obtain the satisfactory achievement. Epilogue Learn from james’ fighting spirit of not bowing to fate Thank you for listening","link":"/2022/03/17/pre/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.^1 Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图]","link":"/2022/03/18/hello-world/"},{"title":"week4","text":"创建个人博客 设置端口，创建博客 更新博客： 在blog/source/_posts下创新的markdown文档，并修改。 返回blog目录，输入hexo clean &amp;&amp; hexo g 返回家目录，输入rsync -ahvP /root/blog/public/ /usr/share/nginx/html/vs网页版 创建完vs网页版后，要保持终端不能关闭 方法：使用tmux创建新的window，在该window内运行创建vs网页版的代码第四章简单总结 算术运算符(左结合律)：一元正号：+ 一元负号：- 乘法：* 除法：/ 取余:% (参与的对象必须是整数类型，m%n的符号与m相同) 逻辑和关系运算符： 关系运算符：&lt; &lt;= &gt; &gt;= == != (左结合) 逻辑运算符： ！(右) &amp;&amp;(左) || (左) 赋值运算符(右结合)优先级低于关系运算符 递增和递减运算符（注：可能会引起未定义问题） 成员访问运算符 ptr-&gt;men=(*ptr).men 条件运算符 x？y：z 若x成立，表达式值为y；反之为z。 位运算符 运算符 功能 ~ 位求反 &lt;&lt; 左移 &gt;&gt; 右移 &amp; 位与 ^ 位异或 sizeof 运算符(右结合律，结合律、优先级和*一样) 两种形式：sizeof(type)sizeof expr例子： sizeof p // 指针所占空间大小sizeof *p // p所指类型的空间大小 逗号运算符对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃吊。 类型转换隐形转换包括常量整数值 0 或者字面值nullptr能转换为任意指针类型指向任意非常量的指针能转换成void*指向任意对象的指针能转换为 const void * 显示转换 static_cast 只要不含有底层const，都可以使用static_cast double slope = static_cast x；//正确const char *p；char * x=static _ cast&lt;char *&gt; (p) // 错误，不能改变底层const const_cast只能改变底层const reinterpert_cast int *ip；char *pc=reinterpert_cast&lt;char *&gt;(ip)//pc所指向的真实对象是一个int而非字符","link":"/2022/03/18/week4/"},{"title":"WEEK5","text":"WEEK5语句 5.1 简单语句 末尾加上分号就变成了表达式语句 空语句：只有一个单独的分号 123while(cin &gt;&gt; s &amp;&amp; s != sought);//空语句 WARING:多余的空语句并非总是无害的！ 复合语句(别称块) 所谓空块，是指内部没有任何语句的一对花括号。等价于空语句 5.2 语句作用域5.3 条件语句 5.3.1 if 语句 if else语句 嵌套语句(注意花括号) 悬垂else if 多于else，不知匹配关系 对于c++，规定else匹配离它最近的if。 5.3.2 switch语句123456789switch(ch){ case'a'： case'b'： break；//a b两种情况执行相同命令，共用一个break case 10： break； case 3.14： // case后必须带整型常量表达式 default: break;//其他所有情况}// 每个case语句后为安全起见，都要带break语句，以防程序继续执行其他case下的语句。 switch内部变量定义 switch执行流程可能跨过某些case标签。 c++规定，不允许跨过变量的初始化语句的情况下直接跳转到该变量作用域内的另一个位置。 12345678910111213141516171819202122232425262728293031 int a = 2;switch (a) {case 1:{ int x; cout &lt;&lt; 1 &lt;&lt; endl; break;}case 2: x = 100; cout &lt;&lt; x &lt;&lt; endl;} //error：“x”: 未声明的标识符 int a = 2;switch (a) {case 1: int x = 2; cout &lt;&lt; 1 &lt;&lt; endl; break;case 2: cout &lt;&lt; x &lt;&lt; endl;} //error: x初始化被跳过 int a = 2;switch (a) {case 1: int x ; cout &lt;&lt; 1 &lt;&lt; endl; break;case 2: x=100; cout &lt;&lt; x &lt;&lt; endl;} //正确 5.4 迭代语句 while语句 for语句for(initstatement；condition；expession)initstatement定义的变量类型相同。 范围for语句 1234for(declaration ：expression)statement//expression必须是一个序列：花括号初始值列表，数组，vector 或string等对象共同点：拥有能返回迭代器的begin和end成员 do while语句 跳转语句 break语句：跳出所在的条件或循环语句 在嵌套中，作用于最近的循环。 continue语句：跳过当前迭代，继续下次迭代(继续循环) goto语句：label： goto label；！！WARNING：不要在程序中使用goto，与switch类似会跨过某些变量的初始化。 try语句块和异常处理 throw 表达式 throw 后紧随一个表达式，表达式的类型就是抛出的异常类型 throw runtime_error(“DATA must refer to same ISBN”) try语句块 123try{programmestatement//在此throw异常}catch(exception-declaration){handler-statement}catch(){}.... 标准异常 exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供额外的信息。 stdexcept头文件定义了常用的异常类 类型 含义 exception 最常见的问题 runtime_error 只有在运行是才能检测出的问题 range_error 运行时错误：生成的结果超出了有意义的值域范围 overflow_error 运行时：计算上溢 underflow_error 运行时：计算下溢 logic_error 程序逻辑错误 domain_error 参数对于的结果值不存在？ invalid_argument 无效参数？ length_error 视图创建一个超过该类型最大长度的对象 out_of_range 使用一个超出有效范围的值 new头文件定义了bad_alloc异常类型 type_info头文件定义了bad_cast异常类型 note：我们只能以默认初始化的方式初始化exception bad_allocbad_cast对象其他异常类型恰相反，应该用string对象或者c风格字符串初始化这些类型的对象，不允许使用默认初始化。 异常类型只定义了一个名为what的成员函数，没有任何参数，返回值是一个指向c风格字符串的const char*","link":"/2022/03/17/week5note/"},{"title":"week6","text":"函数基础 形参列表中每个形参都要含有声明符(即使两个形参为同一类型)每个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字—-&gt;形参相当于最外层变量 形参可以没有名字，此形参在函数内不能被使用，但是还必须给它传递实参。 函数的返回类型不能是数组或者函数类型，但可以是指向数组或函数的指针。 局部变量 自动对象：只存在于块执行期间的对象 分离式编译 .h头文件包含变量或函数等的声明.cpp文件负责定义最后将各个cpp文件转化为后缀为.obj的对象代码再把对象文件链接为可执行文件 12345678$ cc factmain.cc fact.cc # generate factmain.exe or a.out $ cc factmain.cc fact.cc -o main # generate main or main.exedetails: $ cc -c factmain #generate factmain.o$ cc -c fact.cc$ cc factmian.o fact.o$ cc factmain.o fact.o -o main 参数传递 形参类型为引用，它将绑定到对应的实参上——&gt;可通过改变形参改变实参的值。也可以通过传递指针来改变实参的值123456void reset(int *ip){ *ip=0;}int i =42;reset(&amp;i);//i=0 sugestion: c++中使用引用形参替代指针形参 123456void reset(int &amp;i){ i=0;}int j=42;reset(j);//j=0 $$ ！！顶层const作用于对象本身 $$ 在传递实参的时候形参的顶层const会被忽略C++允许定义多个同名函数但是它们的形参列表要不一样 12void fun(const int i)void fun(int i)//报错 数组引用形参12void f(int (&amp;arr)[10])//主席(&amp;arr)的括号//限制只能作用于大小为10的数组 含有可变形参的函数 initializer_list模板在头文件中initializer使用和vector类似元素永远是常量值 省略符形参目的：为了便于c++程序访问某些特殊的c代码使用了名为varargs的c标准库功能只能出现在形参列表的最后一个位置 12void fun(int x，...)；void fun(...)； 返回类型和return语句 返回void的函数不要求非得有return语句，隐式地执行return。void函数也能使用return expression但是expression必须是某个返回void的函数。 在含有return的循环后面也应该有一句return语句 返回引用的函数得到左值，其他返回类型得到右值。 列表初始化返回值 1234567vector &lt;string&gt; process(){ //... return{}；//返回空列表 return{&quot;hello&quot;,&quot;world&quot;};}//如果函数返回的是内置类型，花括号包围的列表最多包含一个值。 cstdlib头文件定义了两个预处理变量 12return EXIT_FAILURE;return EXIT_SUCCESS; 递归 返回一个返回数组指针的函数 例： int (*fun(int i))[10] 使用尾置返回类型：auto fun(int i) -&gt; int(*)[10] 使用declytype123int odd[5]={1,2,3,4,5}decltype(odd) *arr(int i){...} 函数重载同一作用域内同名但是形参列表不同的几个函数称为重载函数 不允许两个函数除了返回类型外其他所有的要素都相同。 NOTE:在c++中，名字查找发生在类型检查之前 特殊用途语言特性 默认实参 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值 1234string screen (int ht=24,int wid=80,char background=' ')//我们可以使用0-3个实参来调用screen函数、screen();//等价于screen（24，80，‘ ’）screen(10,20);//等价于screen（10，20，‘ ’） 局部变量不能作为默认变量 内联函数调用函数一般比求等价表达式的值要慢一些。将函数指定为内联函数(通常就是将它在每一个调用点上展开)使用：在函数返回类型前加上inline适用： 规模较小，频繁使用的函数 NDEBUG预处理变量已放弃使用assert()的原因是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：12#define NDEBUG#include &lt;cassert&gt; 指向函数的指针12345678//比较两个string对象的长度bool lc(const string &amp;，const string &amp;)；bool (*pf)(const string &amp;，const string &amp;);pf=lc;pf=&amp;lc;//两句等价，&amp;可选//调用bool b1=pf(...)bool b1=(*pf)(...) typedef bool func1()；//别名func为函数类型 typedef bool (*func2)();//func2为指向函数的指针 using func1=bool(); using func2=bool(*)(); 注意：对某个函数名使用decltype返回的是函数类型，不是指针。","link":"/2022/03/25/%E2%80%9Cweek6%E2%80%9D/"},{"title":"","text":"title: week8date: 2022-04-14 09:04:37categories: notetags: c++ 类 类 引入thisstd::string isbn()const {return this-&gt;bookNO;} this的目的总是指向“这个”对象，所以this是一个常量指针*const 引入const成员函数，ibsn函数紧随参数列表后的const关键字是将this指针改为指向常量的常量指针，从而this既可指向常量对象，也可以指向普通对象。 像这样使用const的成员函数被称作常量成员函数。 类作用域和成员函数 在函数外定义类中声明过的函数123doule Sales_data::avg_price()const{ ......} 其中使用到了作用域运算符::表明avg_price()函数是在Sales_data中声明的。 123456total.combine(trans)Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs){......return *this；} *this解引用得到total，返回total的引用。 定义类相关的非成员函数 IO类属于不能拷贝的类型，只能通过引用来传递它们。 123456istream &amp;read(istream &amp;is，Sales_data &amp;item){ is&gt;&gt;...&gt;&gt;...; return is;}//返回cin的引用 构造函数 含义：类通过一个或多个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。 任务：初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数 构造函数的名字和类名相同(多个时需要构造函数在参数数量或参数类型上有所区别) 没有返回类型 有一个(可能为空)的参数列表和一个(可能为空)的函数体 不能被声明为const类型 合成的默认构造函数 如果我们的类没有显示的定义构造函数，编译器就会为我们隐式地定义一个默认构造函数(合成的默认构造函数) 规则： 如果存在类内的初始值(定义类时)， 用它来初始化成员 否则默认初始化该成员 ***note： 1.只有类没有声明任何构造函数时，编译器才会自动的生成默认构造函数 默认初始化的内置类型或复合类型对象的值是未定义的 编译器不能为一些类合成默认构造函数，例如一个类中含有另一个类类型的成员，并且该成员的类型没有默认构造函数*** =default的含义 c++11新标准，如果我们需要默认的行为，那么可以通过在参数列表后面写上=default WARNING:默认构造函数只有在我们为内置类型的数据成员提供了初始值情况下有效 构造函数初始化列表123Sales_data(const std::string &amp;s,unsigned n) : bookNo(s),units_sold(n){ }//注意点：参数列表后的冒号，以及使用()中的值初始化()前的对象 访问控制和封装 定义在public说明符之后的成员在整个程序内可以被访问，定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但不能被使用该类的代码访问。 123456class Sales_data {public：private：}; 使用class或struct关键字的区别：使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，使用class关键字，这些成员是private的。 友元对于Sales_data，read、print、和add函数不是类的成员，因此他们不能访问Sales_data类型对象的非公有成员，解决：使这些接口函数成为类的友元。1234567class Sales_data{ friend Sales_data add(...)//友元定义方式 public: private:}; 友元：类允许其他类或函数访问其成员，方法-&gt;把这些类或函数设置为友元。 1. 友元不是类的成员，友元声明只能出现在类的内部，在类中的具体位置不限，不受所在区域访问控制级别的约束2. 友元在类外还要专门再次声明 类的其他特性 定义一个类型成员123456class Screen{public:typedef std::string::size_type pos//等同于using pos=std::string::size_typeprivate:pos cursor=0；//使用别名pos可以隐藏实现的细节}; 成员函数 12345class Screen{public：char get(pos ht，pos wd) const;//仅声明不需要{}//类内类外都可以设定incline属性(同时设置也合法)}； 可变数据成员123456class Screen{public: void some_member()const;private: mutable size_t access_ctr//在变量声明前加mutable关键字，会使该变量可以被任何成员函数(包括const函数如 some_member)都能改变它的值}; 类类型 即使两个类的成员列表完全一致，它们也是不同的类型。 类的声明和定义与函数一样可以分开。123class Screen;//前向声明，在定义之前它是不完全类型//可以定义指向不完全类型的指针或引用，也可以声明(但不可以定义)以不完全类型作为参数或者返回类型的函数。//在创建该类对象前，必须定义好该类。 note：友元的声明的作用是影响访问权限，他本身并非普通意义上的声明，所以在类的外部必须再次声明 类的作用域 对于类中的类类型成员，要使用作用域运算符访问:: 名字查找 类成员声明的名字查找： 编译器处理完类中的全部声明才会处理成员函数的定义123456789using money=double;string bal;class account{ public: money balance{return bal;} private:money; //...};//编译器看到balance函数的声明时，它将在account中在此函数前的范围寻找money，未找到，到外层作用域查找。最终return bal的bal是money类型。 不能在类中定义和外层相同的别名。$tips:类型名的定义放在类的开始处$ 成员函数定义中的名字查找顺序：此函数作用域-&gt;所在类作用域-&gt;成员函数在外部定义前外层作用域。note:可以使用this-&gt;或 ::强制访问数据成员。而例如::height这样在::前什么都没有的表示全局作用域。 构造函数初始值列表成员实际初始化顺序与他们在类定义中的出现顺序一致，与在构造函数初始值列表中顺序无关。注意：如果使用一个成员初始化另一个成员，要注意二者初始化的顺序 默认实参 12345class Sales_data{ public: Sales_data(std::string s =&quot; &quot;) : bookNo(s){}//s为默认实参};//如果一个构造函数为所有参数定义了默认实参，则它实际上也定义了默认的构造函数。 委托构造函数 12345678class Sales_data{ //非委托构造函数 public: Sales_data(std::string s,unsigned cnt,double price): bookNo(s),units_sold(cnt),revenue(cnt*price) {} //委托构造函数 Sales_data (): Sales_data(&quot;&quot;,0,0){}//此为默认构造函数委托给上面的三参数构造函数。}; 隐式地类类型转换12345//对于接受一个string实参的构造函数//在使用到Sales_data的地方可以用string作为替代string null_book=&quot;123&quot;;item.combine(null_book);//编译器自动用给定的string创建了一个定时的Sales_data对象 编译器只会自动(隐式)指向一步类型转换12345item.combine(&quot;123&quot;) ;//错误，要有两次隐式类型转换item.combine(string(&quot;123&quot;))item.combine( Sales_data(&quot;123&quot;))//上面两种正确 抑制构造函数定义的隐式转换 12345678910class ...{ public: Sales_data()=default; Sales_data(std::string s,unsigned cnt,double price): bookNo(s),units_sold(cnt),revenue(cnt*price) {} explicit Sales_data(const std::string &amp;s)：bookNo(s){} //explicit只对一个实参的构造函数有效，此时item.combine(&quot;123&quot;)不能实现隐式转换。 //explicit关键字不允许重复使用，只能在类内使用。 //强制转换:item.combine(static_cast&lt;Sales_data&gt;(&quot;123&quot;))正确}; 聚合类： 所有成员都是public的 没有定义任何构造函数 没有类内初始值 没有基类？？？？(十四章) 字面值常量类 定义略(P267) 尽管构造函数不能是const的，但是字面值常量类的构造函数可以使constexpe函数 constexpr构造函数必须初始化所有数据成员 类的静态成员123456class account{ ... private: static double interestrate;};// interestrate为所有account对象共享 定义静态成员关键字static只能出现在类内部在类外不能重复static关键字注意点： 使用::域作用符直接访问静态成员 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员函数。 成员函数可以直接使用静态成员 静态成员在类外部被定义和初始化例外：static constexpr int period =10；，静态成员是constexpr类型的可以在类内定义和初始化，但在类外定义时不用提供初始值，初始值与类内初始值保持一致。 静态成员的类型可以就是所属的类类型，而非静态数据成员只能声明成它所属类的指针或引用。 静态成员可以作为默认实参，而非静态成员不可以。","link":"/2022/04/13/week8/"}],"tags":[{"name":"NBA","slug":"NBA","link":"/tags/NBA/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"English pre","slug":"English-pre","link":"/categories/English-pre/"},{"name":"note","slug":"note","link":"/categories/note/"}]}