<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/13/week8/"/>
      <url>/2022/04/13/week8/</url>
      
        <content type="html"><![CDATA[<hr><p>title: week8<br>date: 2022-03-25 09:04:37<br>categories: </p><ul><li>note<br>tags:</li><li>c++</li><li>类</li></ul><hr><p> <font size=6>类</font>  </p><ul><li><p><font size=3> 引入this<br><code>std::string isbn()const   &#123;return this-&gt;bookNO;&#125;</code></p><p> this的目的总是指向“这个”对象，所以this是一个常量指针<code>*const</code> </p></li><li><p>引入const成员函数，ibsn函数紧随参数列表后的const关键字是将this指针改为指向常量的常量指针，从而this既可指向常量对象，也可以指向普通对象。  像这样使用const的成员函数被称作常量成员函数。</p></li></ul><p><font size=5> 类作用域和成员函数</font></p><ol><li><em><strong>在函数外定义类中声明过的函数</strong></em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">doule <span class="title">Sales_data::avg_price</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中使用到了作用域运算符<code>::</code>表明<code>avg_price()</code>函数是在<code>Sales_data</code>中声明的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total.<span class="built_in">combine</span>(trans)</span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>*this</code>解引用得到<code>total</code>，返回<code>total</code>的引用。</p><ol start="2"><li><p>定义类相关的非成员函数<br> IO类属于不能拷贝的类型，只能通过引用来传递它们。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is，Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    is&gt;&gt;...&gt;&gt;...;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回cin的引用</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><p> 含义：类通过一个或多个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。<br> 任务：初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数  </p><ul><li>构造函数的名字和类名相同(多个时需要构造函数在参数数量或参数类型上有所区别)</li><li>没有返回类型</li><li>有一个(可能为空)的参数列表和一个(可能为空)的函数体</li><li>不能被声明为<code>const</code>类型</li></ul></li></ol><ul><li><p>合成的默认构造函数</p><p>  如果我们的类没有显示的定义构造函数，编译器就会为我们隐式地定义一个默认构造函数(合成的默认构造函数)</p><p>  规则：</p><ol><li>如果存在类内的初始值(定义类时)，  用它来初始化成员</li><li>否则默认初始化该成员</li></ol><p>  ***<font color=red>note：<br>  1.只有类没有声明任何构造函数时，编译器才会自动的生成默认构造函数  </p><ol start="2"><li>默认初始化的内置类型或复合类型对象的值是未定义的  </li><li>编译器不能为一些类合成默认构造函数，例如一个类中含有另一个类类型的成员，并且该成员的类型没有默认构造函数</font>***</li></ol></li><li><p><code>=default</code>的含义<br>  c++11新标准，如果我们需要默认的行为，那么可以通过在参数列表后面写上<code>=default</code>  </p></li></ul><p><em><strong><font color=red>WARNING:默认构造函数只有在我们为内置类型的数据成员提供了初始值情况下有效</font></strong></em></p><ul><li>构造函数初始化列表<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s,<span class="type">unsigned</span> n) : <span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n)</span><br><span class="line">&#123;    &#125;</span><br><span class="line"><span class="comment">//注意点：参数列表后的冒号，以及使用()中的值初始化()前的对象</span></span><br></pre></td></tr></table></figure></li><li>访问控制和封装<ul><li>定义在<code>public</code>说明符之后的成员在整个程序内可以被访问，定义类的接口。</li><li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但不能被使用该类的代码访问。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用class或struct关键字的区别：<br>使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，使用class关键字，这些成员是private的。</p><ul><li>友元<br>对于Sales_data，read、print、和add函数不是类的成员，因此他们不能访问Sales_data类型对象的非公有成员，解决：使这些接口函数成为类的友元。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(...)</span><span class="comment">//友元定义方式</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    private:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure></li><li>友元：类允许其他类或函数访问其成员，方法-&gt;把这些类或函数设置为友元。  </li></ul><p><em><strong><font color=red>1. 友元不是类的成员，友元声明只能出现在类的内部，在类中的具体位置不限，不受所在区域访问控制级别的约束<br>2. 友元在类外还要专门再次声明</font></strong></em></p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><ul><li>定义一个类型成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> std::string::size_type pos<span class="comment">//等同于using pos=std::string::size_type</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pos cursor=<span class="number">0</span>；<span class="comment">//使用别名pos可以隐藏实现的细节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>成员函数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(pos ht，pos wd)</span> <span class="type">const</span></span>;<span class="comment">//仅声明不需要&#123;&#125;</span></span><br><span class="line"><span class="comment">//类内类外都可以设定incline属性(同时设置也合法)</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></li><li>可变数据成员<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr<span class="comment">//在变量声明前加mutable关键字，会使该变量可以被任何成员函数(包括const函数如 some_member)都能改变它的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>类类型  <ul><li> 即使两个类的成员列表完全一致，它们也是不同的类型。</li><li>类的声明和定义与函数一样可以分开。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;<span class="comment">//前向声明，在定义之前它是不完全类型</span></span><br><span class="line"><span class="comment">//可以定义指向不完全类型的指针或引用，也可以声明(但不可以定义)以不完全类型作为参数或者返回类型的函数。</span></span><br><span class="line"><span class="comment">//在创建该类对象前，必须定义好该类。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><em><strong>note：友元的声明的作用是影响访问权限，他本身并非普通意义上的声明，所以在类的外部必须再次声明</strong></em></p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul><li><p>对于类中的类类型成员，要使用作用域运算符访问<code>::</code>  </p><h2 id="名字查找"><a href="#名字查找" class="headerlink" title="名字查找"></a>名字查找</h2></li><li><p>类成员声明的名字查找：</p><ul><li>编译器处理完类中的全部声明才会处理成员函数的定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> money=<span class="type">double</span>;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">account</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    money balance&#123;<span class="keyword">return</span> bal;&#125;</span><br><span class="line">    <span class="keyword">private</span>:money;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译器看到balance函数的声明时，它将在account中在此函数前的范围寻找money，未找到，到外层作用域查找。最终return bal的bal是money类型。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不能在类中定义和外层相同的别名。<br>$tips:类型名的定义放在类的开始处$  </p></li><li><p>成员函数定义中的名字查找<br>顺序：此函数作用域-&gt;所在类作用域-&gt;成员函数在外部定义前外层作用域。<br>note:可以使用<code>this-&gt;</code>或 <code>::</code>强制访问数据成员。<br>而例如<code>::height</code>这样在<code>::</code>前什么都没有的表示全局作用域。</p></li></ul><h2 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><p>成员实际初始化顺序与他们在类定义中的出现顺序一致，与在构造函数初始值列表中顺序无关。<br><font color=red>注意：如果使用一个成员初始化另一个成员，要注意二者初始化的顺序</font>  </p><ul><li><p>默认实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Sales_data</span>(std::string s =<span class="string">&quot; &quot;</span>) : <span class="built_in">bookNo</span>(s)&#123;&#125;<span class="comment">//s为默认实参</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果一个构造函数为所有参数定义了默认实参，则它实际上也定义了默认的构造函数。</span></span><br></pre></td></tr></table></figure></li><li><p>委托构造函数  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//非委托构造函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Sales_data</span>(std::string s,<span class="type">unsigned</span> cnt,<span class="type">double</span> price):</span><br><span class="line">        <span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cnt*price) &#123;&#125;</span><br><span class="line">    <span class="comment">//委托构造函数</span></span><br><span class="line">        <span class="built_in">Sales_data</span> ():  <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;<span class="comment">//此为默认构造函数委托给上面的三参数构造函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="隐式地类类型转换"><a href="#隐式地类类型转换" class="headerlink" title="隐式地类类型转换"></a>隐式地类类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于接受一个string实参的构造函数</span></span><br><span class="line"><span class="comment">//在使用到Sales_data的地方可以用string作为替代</span></span><br><span class="line">string null_book=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br><span class="line"><span class="comment">//编译器自动用给定的string创建了一个定时的Sales_data对象</span></span><br></pre></td></tr></table></figure></li><li><ol><li>编译器只会自动(隐式)指向一步类型转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;123&quot;</span>) ;</span><br><span class="line"><span class="comment">//错误，要有两次隐式类型转换</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">item.<span class="built_in">combine</span>( <span class="built_in">Sales_data</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="comment">//上面两种正确</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>抑制构造函数定义的隐式转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ...&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s,<span class="type">unsigned</span> cnt,<span class="type">double</span> price):</span><br><span class="line">        <span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(cnt),<span class="built_in">revenue</span>(cnt*price) &#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>：<span class="title">bookNo</span><span class="params">(s)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//explicit只对一个实参的构造函数有效，此时item.combine(&quot;123&quot;)不能实现隐式转换。</span></span><br><span class="line">    <span class="comment">//explicit关键字不允许重复使用，只能在类内使用。</span></span><br><span class="line">    <span class="comment">//强制转换:item.combine(static_cast&lt;Sales_data&gt;(&quot;123&quot;))正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>聚合类：  </p></li></ul><ol><li>所有成员都是public的</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类？？？？(十四章)</li></ol><ul><li>字面值常量类  </li></ul><ol><li>定义略(P267)</li><li>尽管构造函数不能是const的，但是字面值常量类的构造函数可以使constexpe函数</li><li>constexpr构造函数必须初始化所有数据成员</li></ol><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">account</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestrate;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// interestrate为所有account对象共享</span></span><br></pre></td></tr></table></figure><ul><li>定义静态成员<br>关键字static只能出现在类内部<br>在类外不能重复static关键字<br>注意点：  </li></ul><ol><li>使用<code>::</code>域作用符直接访问静态成员</li><li>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员函数。  </li><li>成员函数可以直接使用静态成员  </li><li>静态成员在类外部被定义和初始化<br>例外：<code>static constexpr int  period =10；</code>，静态成员是constexpr类型的可以在类内定义和初始化，但在类外定义时不用提供初始值，初始值与类内初始值保持一致。</li><li>静态成员的类型可以就是所属的类类型，而非静态数据成员只能声明成它所属类的指针或引用。</li><li>静态成员可以作为默认实参，而非静态成员不可以。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>week6</title>
      <link href="/2022/03/25/%E2%80%9Cweek6%E2%80%9D/"/>
      <url>/2022/03/25/%E2%80%9Cweek6%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title=" 函数基础"></a><font size=7> 函数基础</font></h1><ul><li>形参列表中每个形参都要含有声明符(即使两个形参为同一类型)<br>每个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字—-&gt;形参相当于最外层变量</li><li>形参可以没有名字，此形参在函数内不能被使用，但是还必须给它传递实参。</li><li>函数的返回类型不能是数组或者函数类型，但可以是指向数组或函数的指针。</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title=" 局部变量 "></a><font size=6> 局部变量 </font></h2><ul><li>自动对象：<br>只存在于块执行期间的对象<h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title=" 分离式编译 "></a><font size=6> 分离式编译 </font></h2></li><li><code>.h</code>头文件包含变量或函数等的声明<br><code>.cpp</code>文件负责定义<br>最后将各个cpp文件转化为后缀为.obj的对象代码<br>再把对象文件链接为可执行文件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cc factmain.cc fact.cc  <span class="comment"># generate factmain.exe or a.out </span></span><br><span class="line">$ cc factmain.cc fact.cc -o main <span class="comment"># generate main or main.exe</span></span><br><span class="line"></span><br><span class="line">details:  </span><br><span class="line">$ cc -c factmain <span class="comment">#generate factmain.o</span></span><br><span class="line">$ cc -c fact.cc</span><br><span class="line">$ cc factmian.o fact.o</span><br><span class="line">$ cc factmain.o fact.o -o main </span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><font size=6>参数传递</font></h2></li><li>形参类型为引用，它将绑定到对应的实参上<br><code>——&gt;</code>可通过改变形参改变实参的值。也可以通过传递指针来改变实参的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);<span class="comment">//i=0</span></span><br></pre></td></tr></table></figure></li></ul><p><em><strong>sugestion: c++中使用引用形参替代指针形参</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> j=<span class="number">42</span>;</span><br><span class="line"><span class="built_in">reset</span>(j);<span class="comment">//j=0</span></span><br></pre></td></tr></table></figure><p>$$ ！！顶层const作用于对象本身  $$  </p><ul><li><p>在传递实参的时候形参的顶层const会被忽略<br>C++允许定义多个同名函数但是它们的形参列表要不一样  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//报错</span></span></span><br></pre></td></tr></table></figure><h2 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a><font size=6>数组引用形参</font></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span><span class="comment">//主席(&amp;arr)的括号</span></span></span><br><span class="line"><span class="function"><span class="comment">//限制只能作用于大小为10的数组</span></span></span><br></pre></td></tr></table></figure><h2 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a><font size=6>含有可变形参的函数</font></h2></li><li><p>initializer_list模板在头文件<initializer_list>中<br>initializer使用和vector类似<br>元素永远是常量值</p></li><li><p>省略符形参<br>目的：为了便于c++程序访问某些特殊的c代码<br>使用了名为varargs的c标准库功能<br>只能出现在形参列表的最后一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x，...)</span>；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(...)</span>；</span></span><br></pre></td></tr></table></figure><h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a><font size=6>返回类型和return语句</font></h2></li><li><p>返回void的函数不要求非得有return语句，隐式地执行return。<br>void函数也能使用<code>return expression</code>但是expression必须是某个返回void的函数。</p></li><li><p>在含有return的循环后面也应该有一句return语句</p></li><li><p>返回引用的函数得到左值，其他返回类型得到右值。  </p></li></ul><p><font size=5>列表初始化返回值</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;string&gt; <span class="built_in">process</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span>&#123;&#125;；<span class="comment">//返回空列表</span></span><br><span class="line">  <span class="keyword">return</span>&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果函数返回的是内置类型，花括号包围的列表最多包含一个值。</span></span><br></pre></td></tr></table></figure><ul><li><code>cstdlib</code>头文件定义了两个预处理变量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br></pre></td></tr></table></figure></li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="返回一个返回数组指针的函数"><a href="#返回一个返回数组指针的函数" class="headerlink" title=" 返回一个返回数组指针的函数"></a><font size=5> 返回一个返回数组指针的函数</font></h2><ol><li>例： <code>int (*fun(int i))[10]</code>  </li><li>使用尾置返回类型：<br><code>auto fun(int i) -&gt; int(*)[10]</code>  </li><li>使用<code>declytype</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arr</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><font size=6>函数重载</font></h2><font size=4>同一作用域内同名但是形参列表不同的几个函数称为重载函数</font></li></ol><p><code>不允许两个函数除了返回类型外其他所有的要素都相同。</code></p><p><font color=red>NOTE:在c++中，名字查找发生在类型检查之前</font></p><h1 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h1><ul><li>默认实参</li></ul><ol><li>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span> <span class="params">(<span class="type">int</span> ht=<span class="number">24</span>,<span class="type">int</span> wid=<span class="number">80</span>,<span class="type">char</span> background=<span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//我们可以使用0-3个实参来调用screen函数、</span></span></span><br><span class="line"><span class="function"><span class="title">screen</span><span class="params">()</span></span>;<span class="comment">//等价于screen（24，80，‘ ’）</span></span><br><span class="line"><span class="built_in">screen</span>(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//等价于screen（10，20，‘ ’）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>局部变量不能作为默认变量</li></ol><ul><li>内联函数<br>调用函数一般比求等价表达式的值要慢一些。<br>将函数指定为内联函数(通常就是将它在每一个调用点上展开)<br>使用：在函数返回类型前加上<code>inline</code><br>适用： 规模较小，频繁使用的函数  </li></ul><ol start="3"><li>NDEBUG预处理变量<br>已放弃使用assert()的原因是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include <cassert>的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a><font size=5>指向函数的指针</font></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lc</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span>；</span></span><br><span class="line"><span class="function"><span class="title">bool</span> <span class="params">(*pf)</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">pf=lc;</span><br><span class="line">pf=&amp;lc;<span class="comment">//两句等价，&amp;可选</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">bool</span> b1=<span class="built_in">pf</span>(...)</span><br><span class="line"><span class="type">bool</span> b1=(*pf)(...)</span><br></pre></td></tr></table></figure><pre><code class="C++">typedef bool func1()；//别名func为函数类型typedef bool (*func2)();//func2为指向函数的指针using func1=bool();using func2=bool(*)();注意：对某个函数名使用decltype返回的是函数类型，不是指针。</code></pre>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week4</title>
      <link href="/2022/03/18/week4/"/>
      <url>/2022/03/18/week4/</url>
      
        <content type="html"><![CDATA[<h2 id="创建个人博客"><a href="#创建个人博客" class="headerlink" title="创建个人博客"></a>创建个人博客</h2><ul><li>设置端口，创建博客</li><li>更新博客：<ol><li>在blog/source/_posts下创新的markdown文档，并修改。</li><li>返回blog目录，输入hexo clean &amp;&amp; hexo g<br>  返回家目录，输入rsync -ahvP /root/blog/public/ /usr/share/nginx/html/<h2 id="vs网页版"><a href="#vs网页版" class="headerlink" title="vs网页版"></a>vs网页版</h2></li></ol></li><li>创建完vs网页版后，要保持终端不能关闭<br>  方法：使用tmux创建新的window，在该window内运行创建vs网页版的代码<h2 id="第四章简单总结"><a href="#第四章简单总结" class="headerlink" title="第四章简单总结"></a>第四章简单总结</h2></li><li>算术运算符(左结合律)：一元正号：+ 一元负号：- 乘法：* 除法：/  取余:% (参与的对象必须是整数类型，m%n的符号与m相同)</li><li>逻辑和关系运算符：</li></ul><ol><li>关系运算符：&lt; &lt;= &gt; &gt;= == != (左结合)</li><li>逻辑运算符： ！(右) &amp;&amp;(左) || (左)</li></ol><ul><li><p> 赋值运算符(右结合)<br>优先级低于关系运算符</p></li><li><p>递增和递减运算符（注：可能会引起未定义问题）</p></li><li><p>成员访问运算符<br>  ptr-&gt;men=(*ptr).men</p></li><li><p>条件运算符<br>  x？y：z<br>  若x成立，表达式值为y；反之为z。</p></li><li><p>位运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">~</td><td align="center">位求反</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td></tr><tr><td align="center">&amp;</td><td align="center">位与</td></tr><tr><td align="center">^</td><td align="center">位异或</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>sizeof 运算符(右结合律，结合律、优先级和*一样)</p></li></ul><p>两种形式：<br>sizeof(type)<br>sizeof expr<br>例子： sizeof p // 指针所占空间大小<br>sizeof *p  // p所指类型的空间大小</p><ul><li>逗号运算符<br>对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃吊。</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h1 id="隐形转换"><a href="#隐形转换" class="headerlink" title="隐形转换"></a>隐形转换</h1><p>包括常量整数值 0 或者字面值nullptr能转换为任意指针类型<br>指向任意非常量的指针能转换成void*<br>指向任意对象的指针能转换为 const void * </p><h1 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h1><ul><li>static_cast </li></ul><p>只要不含有底层const，都可以使用static_cast</p><hr><p>double slope = static_cast<double> x；//正确<br>const char *p；<br>char * x=static _ cast&lt;char *&gt; (p) // 错误，不能改变底层const</p><hr><ul><li><p>const_cast<br>只能改变底层const</p></li><li><p>reinterpert_cast</p></li></ul><hr><p>int *ip；<br>char *pc=reinterpert_cast&lt;char *&gt;(ip)<br>//pc所指向的真实对象是一个int而非字符</p><hr>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/18/hello-world/"/>
      <url>/2022/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p><u>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</u><a href="hello">^1</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>James</title>
      <link href="/2022/03/17/pre/"/>
      <url>/2022/03/17/pre/</url>
      
        <content type="html"><![CDATA[<h1 id="lebron-james"><a href="#lebron-james" class="headerlink" title="lebron james"></a><font size=12 color=blue  face="STCAIYUN"><em><strong>lebron james</strong></em></font></h1><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2022/0320/29f25071j00r90zj4002kc000hs00npg.jpg&thumbnail=660x800&quality=80&type=jpg"></p><h2 id="lebron-james-is-my-favorite-NBA-player-today-3-20-his-career-score-rose-to-second-in-history-I-would-like-to-introduce-this-great-star-to-you"><a href="#lebron-james-is-my-favorite-NBA-player-today-3-20-his-career-score-rose-to-second-in-history-I-would-like-to-introduce-this-great-star-to-you" class="headerlink" title="lebron james is my favorite NBA player, today(3.20),his career score rose to second in history.I would like to introduce this great star to you"></a><em><strong>lebron james is my favorite NBA player, today(3.20),his career score rose to second in history.I would like to introduce this great star to you</strong></em></h2><hr><p><img src="/~/pre/james.jpeg">  </p><hr><p><font size=12 color=#008000  face="STCAIYUN"> Difficult childhood </font></p><h2 id="December-30-1984"><a href="#December-30-1984" class="headerlink" title="December 30 1984"></a><em><strong>December 30 1984</strong></em></h2><ul><li> <em><strong><font size=6>Lebron was born in the akron ghetto in ohio,USA.However,his father abandoned him and his mother.</font></strong></em></li><li><em><strong><font size=6>He and his mother live in grandma’s rental house.They three depended on each other for survival.Unfortunately his grandma passed away at his 3 years old.</font></strong></em></li><li> <em><strong><font size=6>Because his mother couldn’t find a stable job,james had moved 12 times since he was 5 </font></strong></em></li></ul><hr><blockquote><p><font size=12 color=red  face="STCAIYUN"><em><strong>James’s basketball enlightment</strong></em></font></p><blockquote><ul><li><em><strong><font size=6 >At his 3,his mother give him a basketball as the birthday gift. He loved the baskketball very much.Even when sleeping,he still holding the ball</font></strong></em>   </li><li><em><strong><font size=6> At his 7,james’ exllent atheletic talent caught Coach Walker attention.Walker taught james basketball skills.And the little james always enjoys training .Soon James has surpassed other kids of the same age </div></strong></em></li></ul></blockquote></blockquote><hr><h2 id="Young-James"><a href="#Young-James" class="headerlink" title="Young James "></a><font size=12 color=green  face="STCAIYUN">Young James </font></h2><p><img src="https://pics2.baidu.com/feed/0d338744ebf81a4c7d1f917af8b5c95e242da6fe.jpeg?token=6eb6257c29eee7d1f9fc97da29245693"></p><p><em><strong><font size=6>In four years of high school, he won the state championship three times, and was selected as an American star three times.</font></strong></em></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_mini%2Cc_zoom%2Cw_640%2Fimages%2F20171012%2F54ad7d9f477342bbb56aa866c4ebec8b.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650355641&t=c38574dcd0d7070af28c50e7c2d09779"></p><ul><li><em><strong><font size=6>the AP(associated press ) called him “the son of heaven”.</font></strong></em></li><li><em><strong><font size=6>And James was extolled  as the first high school student in the US</font></strong></em></li></ul><p><font size=12 color=blue  face="STCAIYUN"> James in NBA </font><br><img src="https://pics6.baidu.com/feed/03087bf40ad162d9c1644e0f214000eb8b13cd45.jpeg?token=2cbcaea67f97518053e63cad99238232"></p><p><em><strong><font size=6 >In 2003, James was selected by the Cleveland Cavaliers as the champion into NBA</font></strong></em></p><h2 id="Achievements"><a href="#Achievements" class="headerlink" title="Achievements"></a><em><strong>Achievements</strong></em></h2><p><em><strong><font size=6> With superb skills and leadership,Jame has won four championships.</font></strong></em><br><img src="https://pics4.baidu.com/feed/0df3d7ca7bcb0a465238d807a9da8d236b60af33.jpeg?token=995ceb556cac658e7057ffd72a036feb"></p><p><font size=12 color=7FFf7F00  face="STCAIYUN"> James Off court</font></p><ul><li><em><strong>very frugal</strong></em></li><li><em><strong><font color=red>Charitable contribution</font></strong></em><ul><li><em><strong>2015 project” I Promise”,donated 87 million dollars</strong></em></li><li><em><strong>2016 donated 41 million 800 thousand dollars to akron</strong></em></li><li><em><strong>and so on</strong></em><br><img src="https://pics6.baidu.com/feed/4034970a304e251f549930f1f4ec0b1f7e3e53c4.jpeg?token=82633f919026497babee6a5e45ebe9ac"></li></ul></li></ul><p><font size=12 color=blue  face="STCAIYUN">Blessing</font></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F12119054926%2F1000.jpg&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650361205&t=0cde639476cddff0972aee7894c4b15e"></p><p> <em><strong><font size=7>I hope James can obtain  the satisfactory achievement.</font></strong></em></p><h1 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a><font size=12 color=blue  face="STCAIYUN">Epilogue</font></h1><p> <em><strong><font size=7 color=gold>Learn from  james’ fighting spirit of not bowing to fate</font></strong></em></p><p><em><strong><font size=12 color=blue  face="STCAIYUN">Thank you for listening</font></strong></em></p>]]></content>
      
      
      <categories>
          
          <category> English pre </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEEK5</title>
      <link href="/2022/03/17/week5note/"/>
      <url>/2022/03/17/week5note/</url>
      
        <content type="html"><![CDATA[<h1 id="WEEK5"><a href="#WEEK5" class="headerlink" title="WEEK5"></a>WEEK5</h1><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p><img src="https://s3.bmp.ovh/imgs/2022/03/c245dd829710adb9.png"></p><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><ul><li><p>末尾加上分号就变成了表达式语句<br>  空语句：只有一个单独的分号</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">;//空语句</span><br></pre></td></tr></table></figure><ul><li>WARING:多余的空语句并非总是无害的！ </li></ul></li><li><h2 id="复合语句-别称块"><a href="#复合语句-别称块" class="headerlink" title="复合语句(别称块)"></a>复合语句(别称块)</h2><p> 所谓空块，是指内部没有任何语句的一对花括号。等价于空语句</p><h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><ul><li> 5.3.1   if 语句</li></ul><ol><li>if else语句</li><li>嵌套语句(注意花括号)</li><li>悬垂else<br> if 多于else，不知匹配关系<br> 对于c++，规定else匹配离它最近的if。</li></ol><ul><li>5.3.2 switch语句<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch(ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span><span class="string">&#x27;a&#x27;</span>：</span><br><span class="line">    <span class="keyword">case</span><span class="string">&#x27;b&#x27;</span>：     <span class="built_in">break</span>；//a b两种情况执行相同命令，共用一个<span class="built_in">break</span></span><br><span class="line">    <span class="keyword">case</span> 10：      <span class="built_in">break</span>；</span><br><span class="line">    <span class="keyword">case</span> 3.14：    // <span class="keyword">case</span>后必须带整型常量表达式 </span><br><span class="line">    default:   <span class="built_in">break</span>;//其他所有情况</span><br><span class="line">&#125;</span><br><span class="line">// 每个<span class="keyword">case</span>语句后为安全起见，都要带<span class="built_in">break</span>语句，以防程序继续执行其他<span class="keyword">case</span>下的语句。</span><br></pre></td></tr></table></figure></li><li>switch内部变量定义<br>  switch执行流程可能跨过某些case标签。<br>  c++规定，不允许跨过变量的初始化语句的情况下直接跳转到该变量作用域内的另一个位置。</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   int a = 2;</span><br><span class="line">switch (a) &#123;</span><br><span class="line"><span class="keyword">case</span> 1:</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">cout &lt;&lt; <span class="string">1 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">case 2: </span></span><br><span class="line"><span class="string">x = 100;</span></span><br><span class="line"><span class="string">cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125; //error：“x”: 未声明的标识符</span></span><br><span class="line"><span class="string">    int a = 2;</span></span><br><span class="line"><span class="string">switch (a) &#123;</span></span><br><span class="line"><span class="string">case 1</span>:</span><br><span class="line">int x = 2;</span><br><span class="line">cout &lt;&lt; <span class="string">1 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">case 2: </span></span><br><span class="line"><span class="string">cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;  //error: x初始化被跳过</span></span><br><span class="line"><span class="string">   int a = 2;</span></span><br><span class="line"><span class="string">switch (a) &#123;</span></span><br><span class="line"><span class="string">case 1</span>:</span><br><span class="line">int x ;</span><br><span class="line">cout &lt;&lt; <span class="string">1 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">case 2: </span></span><br><span class="line"><span class="string">x=100;</span></span><br><span class="line"><span class="string">cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125; //正确</span></span><br></pre></td></tr></table></figure><h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><ul><li>while语句</li><li>for语句<br>for(initstatement；condition；expession)<br>initstatement定义的变量类型相同。</li><li><h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration ：expression)</span><br><span class="line">statement</span><br><span class="line">//expression必须是一个序列：花括号初始值列表，数组，vector 或string等对象</span><br><span class="line">共同点：拥有能返回迭代器的begin和end成员</span><br></pre></td></tr></table></figure><ul><li>do while语句</li></ul><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><ul><li>break语句：跳出所在的条件或循环语句<br>  在嵌套中，作用于最近的循环。</li><li>continue语句：跳过当前迭代，继续下次迭代(继续循环)</li><li>goto语句：label：<br>  goto label；<br>！！WARNING：不要在程序中使用goto，与switch类似会跨过某些变量的初始化。</li></ul><h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><ul><li>throw 表达式</li></ul><p> throw 后紧随一个表达式，表达式的类型就是抛出的异常类型<br> throw runtime_error(“DATA must refer to same ISBN”)</p><ul><li>try语句块</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;programmestatement//在此throw异常&#125;</span><br><span class="line">catch(exception-declaration)&#123;handler-statement&#125;</span><br><span class="line"><span class="function"><span class="title">catch</span></span>()&#123;&#125;....</span><br></pre></td></tr></table></figure><ul><li>标准异常</li><li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供额外的信息。</li><li>stdexcept头文件定义了常用的异常类</li></ul><table><thead><tr><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">exception</td><td align="center">最常见的问题</td></tr><tr><td align="center">runtime_error</td><td align="center">只有在运行是才能检测出的问题</td></tr><tr><td align="center">range_error</td><td align="center">运行时错误：生成的结果超出了有意义的值域范围</td></tr><tr><td align="center">overflow_error</td><td align="center">运行时：计算上溢</td></tr><tr><td align="center">underflow_error</td><td align="center">运行时：计算下溢</td></tr><tr><td align="center">logic_error</td><td align="center">程序逻辑错误</td></tr><tr><td align="center">domain_error</td><td align="center">参数对于的结果值不存在？</td></tr><tr><td align="center">invalid_argument</td><td align="center">无效参数？</td></tr><tr><td align="center">length_error</td><td align="center">视图创建一个超过该类型最大长度的对象</td></tr><tr><td align="center">out_of_range</td><td align="center">使用一个超出有效范围的值</td></tr></tbody></table><ul><li><p>new头文件定义了bad_alloc异常类型</p></li><li><p>type_info头文件定义了bad_cast异常类型</p></li><li><p>note：我们只能以默认初始化的方式初始化exception bad_alloc<br>bad_cast对象<br>其他异常类型恰相反，应该用string对象或者c风格字符串初始化这些类型的对象，不允许使用默认初始化。</p></li><li><p>异常类型只定义了一个名为what的成员函数，没有任何参数，返回值是一个指向c风格字符串的const char*</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
